<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Generative Art Prototype</title>
  <style>
    body {
      margin: 0;
      background-color: #fafafa;
      padding: 40px;
      transform: scale(2.3);
      transform-origin: top;
    }
    #controls {
      background: rgba(255,255,255,0.8);
      padding: 8px;
      border-radius: 4px;
      margin: 0 auto 20px auto;
      width: fit-content;
    }
    #canvas {
      display: block;
      cursor: pointer;
      width: 300px;
      height: 300px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="algo">Algorithm:</label>
    <select id="algo">
      <option value="dla">Crystal Growth</option>
      <option value="colorfill">Color-Influenced Fill</option>
    </select>
  </div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    canvas.width = 300;
    canvas.height = 300;
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, 300, 300);

    document.getElementById('algo').addEventListener('change', () => {
      // nothing to do here yet
    });

    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      // Convert click coordinates to canvas space
      const x = Math.floor((e.clientX - rect.left) * (300 / rect.width));
      const y = Math.floor((e.clientY - rect.top) * (300 / rect.height));
      const algo = document.getElementById('algo').value;
      if (algo === 'dla') {
        runDLA(x, y);
      } else if (algo === 'colorfill') {
        runColorFill(x, y);
      } else {
        alert('algo not implemented yet: ' + algo);
      }
    });

    // --- Algorithm 1: Diffusion-Limited Aggregation (Crystal Growth) ---
    function runDLA(seedX, seedY) {
      const w = canvas.width;
      const h = canvas.height;
      const img = ctx.getImageData(0, 0, w, h); 
      const visited = new Set(); // Stores "x,y" for DLA particles

      let aggregatedParticlesCount = 0;
      // Stop when 20% of canvas is filled by DLA, or 10k particles, whichever is smaller
      // const MAX_PARTICLES = Math.min(Math.floor((w * h) * 0.20), 10000); 
      const MAX_PARTICLES = w * h;
      console.log("MAX_PARTICLES", MAX_PARTICLES);
      const MAX_WALKER_STEPS = Math.max(w,h) * 5; // Max steps before a walker is considered lost
      
      const PARTICLES_PER_FRAME = 100; // Number of walkers to process per animation frame
      const MAX_CONSECUTIVE_SPAWN_FAILS_TOTAL = 10000; // If 300 total spawn attempts fail in a row, stop.
      let consecutiveSpawnFails = 0;
      let particlesSinceLastDraw = 0; // Counter for particles since last draw
      const DRAW_INTERVAL = 5; // Draw after this many particles are added


      // --- Color generation (adapted from runColorFill) ---
      const DLA_SIMILARITY_PERCENT = 0.99; 
      const DLA_SIMILAR_VARIATION = 5;   
      const DLA_DISSIMILAR_VARIATION = 40;

      function getDlaNeighborColors(x, y) {
        const colors = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < w && ny >= 0 && ny < h && visited.has(`${nx},${ny}`)) {
              const idx = (ny * w + nx) * 4;
              colors.push({
                r: img.data[idx],
                g: img.data[idx + 1],
                b: img.data[idx + 2]
              });
            }
          }
        }
        return colors;
      }

      function generateDlaInfluencedColor(neighborColors) {
        if (neighborColors.length === 0) {
          return { 
            r: Math.random() * 255,
            g: Math.random() * 255,
            b: Math.random() * 255
          };
        }
        
        const avg = neighborColors.reduce((acc, col) => ({
          r: acc.r + col.r / neighborColors.length,
          g: acc.g + col.g / neighborColors.length,
          b: acc.b + col.b / neighborColors.length
        }), { r: 0, g: 0, b: 0 });
        
        // If 4 or more neighbors are filled, always use similar
        let useSimilar = false;
        if (neighborColors.length >= 4) {
          useSimilar = true;
        } else {
          useSimilar = Math.random() < DLA_SIMILARITY_PERCENT;
        }
        const variation = useSimilar ? DLA_SIMILAR_VARIATION : DLA_DISSIMILAR_VARIATION;
        
        return {
          r: Math.min(255, Math.max(0, avg.r + (Math.random() - 0.5) * variation * 2)),
          g: Math.min(255, Math.max(0, avg.g + (Math.random() - 0.5) * variation * 2)),
          b: Math.min(255, Math.max(0, avg.b + (Math.random() - 0.5) * variation * 2))
        };
      }
      // --- End Color generation ---

      function paintPixel(x, y, color) {
        if (x < 0 || x >= w || y < 0 || y >= h) return;
        const idx = (y * w + x) * 4;
        img.data[idx] = color.r;
        img.data[idx + 1] = color.g;
        img.data[idx + 2] = color.b;
        img.data[idx + 3] = 255; 
      }

      if (seedX < 0 || seedX >= w || seedY < 0 || seedY >= h) {
          console.error("DLA seed is out of bounds.");
          return;
      }
      
      // Clear canvas with white before starting new DLA
      // ctx.fillStyle = '#fff'; // Assuming global ctx is fine
      // ctx.fillRect(0, 0, w, h);
      // for (let i = 0; i < img.data.length; i += 4) {
      //    img.data[i] = 255; img.data[i+1] = 255; img.data[i+2] = 255; img.data[i+3] = 255;
      // }
      // Decided against auto-clearing; DLA will draw on existing canvas. Seed point will be fresh.

      const seedColor = generateDlaInfluencedColor([]); 
      paintPixel(seedX, seedY, seedColor);
      visited.add(`${seedX},${seedY}`);
      aggregatedParticlesCount++;
      
      let animationFrameId = null;

      function animationStep() {
        if (aggregatedParticlesCount >= MAX_PARTICLES) {
          console.log("DLA finished: Max particles reached.");
          if (animationFrameId) cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
          ctx.putImageData(img, 0, 0); 
          return;
        }

        if (consecutiveSpawnFails >= MAX_CONSECUTIVE_SPAWN_FAILS_TOTAL) {
            console.log("DLA finished: Too many consecutive spawn failures.");
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            ctx.putImageData(img, 0, 0);
            return;
        }
        
        let particlesAddedThisFrame = 0;

        for (let i = 0; i < PARTICLES_PER_FRAME; i++) {
            if (aggregatedParticlesCount >= MAX_PARTICLES) break;

            let walkerX, walkerY;
            let spawnedSuccessfully = false;
            const MAX_ATTEMPTS_PER_WALKER_SPAWN = 200; 

            for (let attempt = 0; attempt < MAX_ATTEMPTS_PER_WALKER_SPAWN; attempt++) {
                walkerX = Math.floor(Math.random() * w);
                walkerY = Math.floor(Math.random() * h);
                if (!visited.has(`${walkerX},${walkerY}`)) {
                    spawnedSuccessfully = true;
                    consecutiveSpawnFails = 0; // Reset counter as one walker spawned
                    break;
                }
            }

            if (!spawnedSuccessfully) {
                consecutiveSpawnFails++; // Increment for this particle's failed spawn attempt
                continue; // Try to process/spawn the next particle in this frame's batch
            }
            
            let currentWalkerSteps = 0;
            // Walker's random walk loop
            while (currentWalkerSteps < MAX_WALKER_STEPS) {
                currentWalkerSteps++;

                let isAdjacentToAggregate = false;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = walkerX + dx;
                        const ny = walkerY + dy;
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h && visited.has(`${nx},${ny}`)) {
                            isAdjacentToAggregate = true;
                            break;
                        }
                    }
                    if (isAdjacentToAggregate) break;
                }

                if (isAdjacentToAggregate) {
                    // Walker sticks at (walkerX, walkerY) which is currently unvisited
                    const neighborColors = getDlaNeighborColors(walkerX, walkerY);
                    const newColor = generateDlaInfluencedColor(neighborColors);
                    paintPixel(walkerX, walkerY, newColor);
                    visited.add(`${walkerX},${walkerY}`);
                    aggregatedParticlesCount++;
                    particlesAddedThisFrame++;
                    particlesSinceLastDraw++; // Increment for draw interval
                    break; // Walker stuck, its life ends
                }

                const moveDx = Math.floor(Math.random() * 3) - 1;
                const moveDy = Math.floor(Math.random() * 3) - 1;

                if (moveDx === 0 && moveDy === 0) continue; // No move, try new step

                const nextX = walkerX + moveDx;
                const nextY = walkerY + moveDy;

                if (nextX < 0 || nextX >= w || nextY < 0 || nextY >= h) { // Hit boundary
                    break; // Walker lost
                }

                if (visited.has(`${nextX},${nextY}`)) { // Tried to move into existing aggregate
                    break; // Walker lost
                }
                
                walkerX = nextX; // Move to new unvisited position
                walkerY = nextY;
            } // End of walker's random walk loop
        } // End of PARTICLES_PER_FRAME loop

        // NEW logic: Update canvas only after DRAW_INTERVAL particles have been added
        if (particlesSinceLastDraw >= DRAW_INTERVAL) {
            ctx.putImageData(img, 0, 0);
            particlesSinceLastDraw = 0; // Reset counter
        }

        if (aggregatedParticlesCount < MAX_PARTICLES && consecutiveSpawnFails < MAX_CONSECUTIVE_SPAWN_FAILS_TOTAL) {
            animationFrameId = requestAnimationFrame(animationStep);
        } else {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            ctx.putImageData(img, 0, 0); 
            if(aggregatedParticlesCount >= MAX_PARTICLES) console.log("DLA finished: Max particles reached (final check).");
            else console.log("DLA finished: Too many spawn failures (final check).");
        }
      } 

      // If another DLA animation is running, cancel it.
      // This needs a global or closure-scoped variable if runDLA can be called multiple times.
      // For simplicity, we assume one DLA process at a time, new call starts new process.
      // A more robust solution would be:
      // if (window.currentDlaAnimationId) cancelAnimationFrame(window.currentDlaAnimationId);
      // window.currentDlaAnimationId = requestAnimationFrame(animationStep);
      // animationFrameId = window.currentDlaAnimationId;
      
      // Simple start:
      animationFrameId = requestAnimationFrame(animationStep);
    }

    // --- Algorithm 2: Color-Influenced Random Fill ---
    function runColorFill(seedX, seedY) {
      const w = 300, h = 300;
      const visited = new Set();
      const img = ctx.getImageData(0, 0, w, h);
      // Exponent for biasing frontier pixel selection (higher = stronger bias for close pixels)
      const frontierBiasExponent = 3;
      // Exponent for biasing by number of painted neighbors (higher = stronger bias for more neighbors)
      const neighborBiasExponent = 2;
      // Set of frontier pixels: key = "x,y", value = [x, y]
      const frontier = new Map();
      // Cache of weights for each frontier pixel: key = "x,y", value = weight
      const frontierWeights = new Map();
      let lastX = seedX, lastY = seedY;
      // Start with the seed pixel
      function computeWeight(x, y) {
        const dist = Math.hypot(x - lastX, y - lastY);
        // Count painted neighbors
        let neighborCount = 0;
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < w && ny >= 0 && ny < h && visited.has(`${nx},${ny}`)) {
              neighborCount++;
            }
          }
        }
        return Math.pow(neighborCount + 1, neighborBiasExponent) / Math.pow(dist + 1e-2, frontierBiasExponent);
      }
      function addFrontier(x, y) {
        const key = `${x},${y}`;
        if (!visited.has(key) && !frontier.has(key) && x >= 0 && x < w && y >= 0 && y < h) {
          frontier.set(key, [x, y]);
          frontierWeights.set(key, computeWeight(x, y));
        }
      }
      addFrontier(seedX, seedY);

      function getNeighborColors(x, y) {
        const colors = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < w && ny >= 0 && ny < h && visited.has(`${nx},${ny}`)) {
              const idx = (ny * w + nx) * 4;
              colors.push({
                r: img.data[idx],
                g: img.data[idx + 1],
                b: img.data[idx + 2]
              });
            }
          }
        }
        return colors;
      }

      function generateInfluencedColor(neighborColors) {
        // Constants for controlling color similarity/dissimilarity
        const SIMILARITY_PERCENT = 0.9; // 90% similar, 10% dissimilar
        const SIMILAR_VARIATION = 10;   // How close similar colors are to the average
        const DISSIMILAR_VARIATION = 25; // How far dissimilar colors can be from the average
        if (neighborColors.length === 0) {
          return {
            r: Math.random() * 255,
            g: Math.random() * 255,
            b: Math.random() * 255
          };
        }
        // Calculate average color from neighbors
        const avg = neighborColors.reduce((acc, col) => ({
          r: acc.r + col.r / neighborColors.length,
          g: acc.g + col.g / neighborColors.length,
          b: acc.b + col.b / neighborColors.length
        }), { r: 0, g: 0, b: 0 });
        // If 7 or 8 neighbors are filled, always use similar
        let useSimilar = false;
        if (neighborColors.length >= 4) {
          useSimilar = true;
        } else {
          useSimilar = Math.random() < SIMILARITY_PERCENT;
        }
        const variation = useSimilar ? SIMILAR_VARIATION : DISSIMILAR_VARIATION;
        return {
          r: Math.min(255, Math.max(0, avg.r + (Math.random() - 0.5) * variation)),
          g: Math.min(255, Math.max(0, avg.g + (Math.random() - 0.5) * variation)),
          b: Math.min(255, Math.max(0, avg.b + (Math.random() - 0.5) * variation))
        };
      }

      function pickFrontierPixel() {
        // Use cached weights
        const entries = Array.from(frontier.values());
        const weights = entries.map(([x, y]) => frontierWeights.get(`${x},${y}`) || 1);
        const total = weights.reduce((a, b) => a + b, 0);
        let r = Math.random() * total;
        for (let i = 0; i < entries.length; i++) {
          r -= weights[i];
          if (r <= 0) return entries[i];
        }
        return entries[entries.length - 1]; // fallback
      }

      function processPixel(x, y) {
        const idx = (y * w + x) * 4;
        const neighborColors = getNeighborColors(x, y);
        const newColor = generateInfluencedColor(neighborColors);
        img.data[idx] = newColor.r;
        img.data[idx + 1] = newColor.g;
        img.data[idx + 2] = newColor.b;
        img.data[idx + 3] = 255;
        visited.add(`${x},${y}`);
        frontier.delete(`${x},${y}`);
        frontierWeights.delete(`${x},${y}`);
        // Add unvisited neighbors to frontier
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            addFrontier(x + dx, y + dy);
          }
        }
        lastX = x;
        lastY = y;
      }

      let stepCount = 0;
      function step() {
        let count = 0;
        const maxPerFrame = 100;
        while (frontier.size > 0 && count < maxPerFrame) {
          const [x, y] = pickFrontierPixel();
          processPixel(x, y);
          count++;
          stepCount++;
        }
        // Recalculate all weights every 100 steps
        if (stepCount % 100 === 0) {
          for (const [key, [x, y]] of frontier.entries()) {
            frontierWeights.set(key, computeWeight(x, y));
          }
        }
        ctx.putImageData(img, 0, 0);
        if (frontier.size > 0) {
          requestAnimationFrame(step);
        }
      }
      step();
    }
  </script>
</body>
</html>