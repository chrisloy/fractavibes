<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Generative Art Prototype</title>
  <style>
    body {
      margin: 0;
      background-color: #fafafa;
      padding: 40px;
      transform: scale(2.3);
      transform-origin: top;
    }
    #controls {
      background: rgba(255,255,255,0.8);
      padding: 8px;
      border-radius: 4px;
      margin: 0 auto 20px auto;
      width: fit-content;
    }
    #canvas {
      display: block;
      cursor: pointer;
      width: 300px;
      height: 300px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="algo">Algorithm:</label>
    <select id="algo">
      <option value="colorfill">Color-Influenced Fill</option>
      <option value="dla">Crystal Growth</option>
    </select>
  </div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    canvas.width = 300;
    canvas.height = 300;
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, 300, 300);

    document.getElementById('algo').addEventListener('change', () => {
      // nothing to do here yet
    });

    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      // Convert click coordinates to canvas space
      const x = Math.floor((e.clientX - rect.left) * (300 / rect.width));
      const y = Math.floor((e.clientY - rect.top) * (300 / rect.height));
      const algo = document.getElementById('algo').value;
      if (algo === 'dla') {
        runDLA(x, y);
      } else if (algo === 'colorfill') {
        runColorFill(x, y);
      } else {
        alert('algo not implemented yet: ' + algo);
      }
    });

    // --- Algorithm 2: Color-Influenced Random Fill ---
    function runColorFill(seedX, seedY) {
      const w = 300, h = 300;
      const visited = new Set();
      const img = ctx.getImageData(0, 0, w, h);
      // Exponent for biasing frontier pixel selection (higher = stronger bias for close pixels)
      const frontierBiasExponent = 3;
      // Exponent for biasing by number of painted neighbors (higher = stronger bias for more neighbors)
      const neighborBiasExponent = 2;
      // Set of frontier pixels: key = "x,y", value = [x, y]
      const frontier = new Map();
      // Cache of weights for each frontier pixel: key = "x,y", value = weight
      const frontierWeights = new Map();
      let lastX = seedX, lastY = seedY;
      // Start with the seed pixel
      function computeWeight(x, y) {
        const dist = Math.hypot(x - lastX, y - lastY);
        // Count painted neighbors
        let neighborCount = 0;
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < w && ny >= 0 && ny < h && visited.has(`${nx},${ny}`)) {
              neighborCount++;
            }
          }
        }
        return Math.pow(neighborCount + 1, neighborBiasExponent) / Math.pow(dist + 1e-2, frontierBiasExponent);
      }
      function addFrontier(x, y) {
        const key = `${x},${y}`;
        if (!visited.has(key) && !frontier.has(key) && x >= 0 && x < w && y >= 0 && y < h) {
          frontier.set(key, [x, y]);
          frontierWeights.set(key, computeWeight(x, y));
        }
      }
      addFrontier(seedX, seedY);

      function getNeighborColors(x, y) {
        const colors = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < w && ny >= 0 && ny < h && visited.has(`${nx},${ny}`)) {
              const idx = (ny * w + nx) * 4;
              colors.push({
                r: img.data[idx],
                g: img.data[idx + 1],
                b: img.data[idx + 2]
              });
            }
          }
        }
        return colors;
      }

      function generateInfluencedColor(neighborColors) {
        // Constants for controlling color similarity/dissimilarity
        const SIMILARITY_PERCENT = 0.9; // 90% similar, 10% dissimilar
        const SIMILAR_VARIATION = 10;   // How close similar colors are to the average
        const DISSIMILAR_VARIATION = 25; // How far dissimilar colors can be from the average
        if (neighborColors.length === 0) {
          return {
            r: Math.random() * 255,
            g: Math.random() * 255,
            b: Math.random() * 255
          };
        }
        // Calculate average color from neighbors
        const avg = neighborColors.reduce((acc, col) => ({
          r: acc.r + col.r / neighborColors.length,
          g: acc.g + col.g / neighborColors.length,
          b: acc.b + col.b / neighborColors.length
        }), { r: 0, g: 0, b: 0 });
        // If 7 or 8 neighbors are filled, always use similar
        let useSimilar = false;
        if (neighborColors.length >= 4) {
          useSimilar = true;
        } else {
          useSimilar = Math.random() < SIMILARITY_PERCENT;
        }
        const variation = useSimilar ? SIMILAR_VARIATION : DISSIMILAR_VARIATION;
        return {
          r: Math.min(255, Math.max(0, avg.r + (Math.random() - 0.5) * variation)),
          g: Math.min(255, Math.max(0, avg.g + (Math.random() - 0.5) * variation)),
          b: Math.min(255, Math.max(0, avg.b + (Math.random() - 0.5) * variation))
        };
      }

      function pickFrontierPixel() {
        // Use cached weights
        const entries = Array.from(frontier.values());
        const weights = entries.map(([x, y]) => frontierWeights.get(`${x},${y}`) || 1);
        const total = weights.reduce((a, b) => a + b, 0);
        let r = Math.random() * total;
        for (let i = 0; i < entries.length; i++) {
          r -= weights[i];
          if (r <= 0) return entries[i];
        }
        return entries[entries.length - 1]; // fallback
      }

      function processPixel(x, y) {
        const idx = (y * w + x) * 4;
        const neighborColors = getNeighborColors(x, y);
        const newColor = generateInfluencedColor(neighborColors);
        img.data[idx] = newColor.r;
        img.data[idx + 1] = newColor.g;
        img.data[idx + 2] = newColor.b;
        img.data[idx + 3] = 255;
        visited.add(`${x},${y}`);
        frontier.delete(`${x},${y}`);
        frontierWeights.delete(`${x},${y}`);
        // Add unvisited neighbors to frontier
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            addFrontier(x + dx, y + dy);
          }
        }
        lastX = x;
        lastY = y;
      }

      let stepCount = 0;
      function step() {
        let count = 0;
        const maxPerFrame = 100;
        while (frontier.size > 0 && count < maxPerFrame) {
          const [x, y] = pickFrontierPixel();
          processPixel(x, y);
          count++;
          stepCount++;
        }
        // Recalculate all weights every 100 steps
        if (stepCount % 100 === 0) {
          for (const [key, [x, y]] of frontier.entries()) {
            frontierWeights.set(key, computeWeight(x, y));
          }
        }
        ctx.putImageData(img, 0, 0);
        if (frontier.size > 0) {
          requestAnimationFrame(step);
        }
      }
      step();
    }

    // --- Algorithm 1: Diffusion-Limited Aggregation (Crystal Growth) ---
    function runDLA(seedX, seedY) {
      // Ensure coordinates are within bounds
      seedX = Math.max(0, Math.min(400 - 1, Math.floor(seedX)));
      seedY = Math.max(0, Math.min(400 - 1, Math.floor(seedY)));
      
      const img = ctx.getImageData(0, 0, 400, 400);
      const w = 400, h = 400;
      const cluster = new Set([seedY * w + seedX]);
      const toIndex = (px,py) => py*w + px;
      const fromIndex = idx => [idx % w, Math.floor(idx / w)];
      
      // Track the max radius for walker spawn
      let maxDist = 1;
      
      // Seed a small cluster for denser start
      for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
        const nx = seedX + dx, ny = seedY + dy;
        if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
          cluster.add(ny * w + nx);
        }
      }
      
      function dist2(x, y) {
        return (x - seedX) * (x - seedX) + (y - seedY) * (y - seedY);
      }
      
      // Spawn walkers on a full circle around the cluster
      function randPos() {
        const radius = Math.sqrt(maxDist) + 10;
        const angle = Math.random() * 2 * Math.PI;
        return {
          x: Math.floor(seedX + Math.cos(angle) * radius),
          y: Math.floor(seedY + Math.sin(angle) * radius)
        };
      }
      
      function step() {
        let walker = randPos();
        for (let i = 0; i < 2000; i++) {
          // --- Bias: with 30% chance, step toward the seed ---
          if (Math.random() < 0.3) {
            if (walker.x < seedX) walker.x++;
            else if (walker.x > seedX) walker.x--;
            if (walker.y < seedY) walker.y++;
            else if (walker.y > seedY) walker.y--;
          } else {
            // Unbiased random walk
            walker.x += [-1, 0, 1][Math.floor(Math.random() * 3)];
            walker.y += [-1, 0, 1][Math.floor(Math.random() * 3)];
          }
          walker.x = Math.max(0, Math.min(w - 1, walker.x));
          walker.y = Math.max(0, Math.min(h - 1, walker.y));
          const idx = toIndex(walker.x, walker.y);
          // Kill and respawn if walker is too far from seed or at edge
          const d2 = dist2(walker.x, walker.y);
          if (walker.x === 0 || walker.x === w-1 || walker.y === 0 || walker.y === h-1 || d2 > (w/2)*(h/2)) {
            walker = randPos();
            continue;
          }
          // Check neighbors
          for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
            const nx = walker.x + dx, ny = walker.y + dy;
            if (nx >= 0 && nx < w && ny >= 0 && ny < h &&
                cluster.has(ny * w + nx) && Math.hypot(dx, dy) <= 1.5) {
              // stick
              // Paint a 3x3 block centered on the sticking point
              for (let by = -1; by <= 1; by++) for (let bx = -1; bx <= 1; bx++) {
                const px = walker.x + bx, py = walker.y + by;
                const bidx = toIndex(px, py);
                if (px >= 0 && px < w && py >= 0 && py < h && !cluster.has(bidx)) {
                  cluster.add(bidx);
                  const bd2 = dist2(px, py);
                  if (bd2 > maxDist) maxDist = bd2;
                  const distNorm = Math.sqrt(bd2) / (Math.sqrt(w * w + h * h) / 2);
                  const hue = 240 - 240 * distNorm;
                  const saturation = 80 + 20 * distNorm;
                  const lightness = 50;
                  // HSL to RGB
                  const hueNorm = hue / 360;
                  const s = saturation / 100;
                  const l = lightness / 100;
                  const c = (1 - Math.abs(2 * l - 1)) * s;
                  const xcol = c * (1 - Math.abs((hueNorm * 6) % 2 - 1));
                  const m = l - c / 2;
                  let r, g, b;
                  if (hueNorm < 1/6) { r = c; g = xcol; b = 0; }
                  else if (hueNorm < 2/6) { r = xcol; g = c; b = 0; }
                  else if (hueNorm < 3/6) { r = 0; g = c; b = xcol; }
                  else if (hueNorm < 4/6) { r = 0; g = xcol; b = c; }
                  else if (hueNorm < 5/6) { r = xcol; g = 0; b = c; }
                  else { r = c; g = 0; b = xcol; }
                  img.data[bidx * 4 + 0] = (r + m) * 255;
                  img.data[bidx * 4 + 1] = (g + m) * 255;
                  img.data[bidx * 4 + 2] = (b + m) * 255;
                  img.data[bidx * 4 + 3] = 255;
                }
              }
              ctx.putImageData(img, 0, 0);
              return;
            }
          }
        }
      }
      // Run many steps per frame for density and speed
      const loop = () => {
        for (let i = 0; i < 50; i++) step();
        requestAnimationFrame(loop);
      };
      loop();
    }
  </script>
</body>
</html>